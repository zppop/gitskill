JVM
1.前言
2.面向人群及参考书目
3.java及JVM简介
4.java发展的重大事件
5.虚拟机与java虚拟机
6.JVM的整体结构
7.JVM代码执行流程
8.JVM架构类型
9.jvm生命周期
x.JVM发展历程


1.前言
	OOM GC问题 JVM参数设置 实际应用 
	高级语言-汇编语言-机器指令-CPU
	架构师：如何使系统更快，如何避免出现系统瓶颈
	垃圾回收算法，JIT,底层原理
	java和c++区别 ： 内存动态分配 垃圾收集技术
	
2.面向人群及参考书目
	官方规范： hotSpot
	参考书目：java virtual machine Specification /java虚拟机规范/深入理解java虚拟机-jvm高级特性与最佳实践/jvm虚拟机精讲/实战java虚拟机
	
3.java及JVM简介
	JVM：跨语言的平台---kotlin/clojure/Groovy/Scala/Jython/Jruby/javaScript
		只关心字节码文件。 字节码文件-->JVM-->CPU
		java不是最强大的语言，但JVM是最强大的虚拟机!!!???
	字节码：java语言编译成的字节码
	实现多语言混合编程/
	真正理解JVM的工作原理：自己动手写一个吧

4.java发展的重大事件

5.虚拟机与java虚拟机
	虚拟机：虚拟计算机，一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可分为系统虚拟机和程序虚拟机
		系统虚拟机---Visual Box，完全是对物理计算机的仿真
		程序虚拟机--java虚拟机，专门为执行单个计算程序而设计
		java虚拟机：执行java字节码的虚拟计算机，拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成
			JVM平台的各种语言可以共享java虚拟机带来的跨平台性/优秀的垃圾回收器/可靠的即时编译器
			java技术的核心就是java虚拟机，因为所有的java程序都是运行在jVM内部。
			是二进制字节码文件的运行环境，负责装在字节码到其内部，解释/编译为对应平台的机器指令执行。
			
			特点：
				1.一次编译，到处运行
				2.自动内存管理
				3.自动垃圾回收功能
			位置： 用户->字节码文件->JVM->操作系统->硬件(JVM是)

6.JVM的整体结构
	HotSpot VM是目前市面上高性能的虚拟机代表之一。解释器与编译器并存的架构。
	
	class files -> claas loade(类加载子系统)
							| |
							| |
		Runtime Data Area(运行时数据区)
	方法区			Java栈			本地方法栈
	Mehthod Area 	java Stack 	 native  method stack
	
	   堆					程序计数器
	  heap				Program Counter Register
	  | |					  | |   | |	
	  | |                     | |   | |
	 执行引擎		<-->	  本地方法接口    <--  本地方法库
	 Execution				Native Interface
	  Engine

7.java代码执行流程：
			java程序--字节码文件--……
			
8.JVM架构类型
	java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。
		两种架构之间的区别
			基于栈式架构特点：
				设计和实现更简单，适用于资源受限制的系统
				避开了寄存器的分配难题，使用零地址指令方式分配
				指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
				不需要硬件支持，可移植性更好，更好实现跨平台
			基于寄存器架构的特点
				典型的应用是X86的二进制指令集，比如传统的PC及Android的Daclik虚拟机
				指令集架构则完全依赖硬件，可移植性差
				性能优秀和执行更高效
				花费更少的指令去完成一项操作
				在大部分情况下，基于寄存器架构的指令往往都是以一地址指令，二地址指令，和三地址指令为主，而基于栈式架构指令集则是以零地址指令为主
		java使用栈式架构指令集，跨平台，指令集小，指令多，执行性能比寄存器差。
		
9.JVM 生命周期
	启动：
		通过引导类的加载器(bootStrap Class Loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机指令实现指定的。
	执行：
		程序开始执行的时候他才进行，程序结束时完成。（）JPS  javap -v
	退出：
		程序正常执行结束
		执行过程中出现异常或错误而终止
		操作系统出现异常而停止
		某线程执行Runtime或System的exit方法，或RUntime的halt方法
		除此之外，JNI(java native interface)规范 描述了用JNI Invocation API 来加载或卸载java虚拟机时，Java虚拟机退出情况。
		
10.JVM发展历程	
	sun claasic VM 1996第一商用java虚拟机，只提供解释器（无JIT 即时编译器）。 现在的hotspot内嵌了此虚拟机。
	Exact VM：Exact Memory Management 准确式内存管理。高i性能Vm 雏形
	HotSpot VM： JDK1.3 默认虚拟机 桌面端/移动端/服务器端
	BEA 的 JRockit : 专注于服务器端的应用。不关注启动速度，不包含解析器实现，世界上最快的JVM,
	IBM 的J9: 和hotspot接近，在自己的产品上应用速度最快。
	Apache Harmony: Android SDK
	Microsoft JVM： 支持 java Applets.97之后不再用。
	TAOBAO JVM：
	Dalvik VM：android系统应用，执行dex格式文件，基于寄存器架构类型。
	Graal VM: oracle 2018.4 hotspot基础之上。跨语言全栈虚拟机，可以作为任何语言的运行平台使用。
	
	
二。
	1。类加载器
		类加载器子系统 
			作用：负责从文件系统或网络中加载class文件。文件头有特定的文件标识
				ClassLoader 只负责class文件的加载，至于是否能运行，则由Execution Engine 决定
				加载的类信息存放在方法区内，除了类的信息外，方法区还会存放运行时常量池信息，可能还包含字符串字面量和数字常量（这部分信息是class文件中常量池部分的内存映射）。
				

		
			类加载器ClassLoader角色
	类加载过程：
		加载阶段-链接阶段-初始化阶段  链接阶段（验证-准备-解析）
		
			加载：	1通过一个类的全限定名获取定义此类的二进制字节流
					2将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
					3在内存中生成一个代表这个类的Java.lang,class对象，作为方法区这个类的各种数据的访问入口
			链接：
				验证verify：
					1.目的在于确保class文件的字节流中包含信息复核当前虚拟机的要求，保证被加载类的而准确性，不会危害虚拟机的自身安全
					2.主要包括四种验证，文件格式验证/元数据验证/字节码验证/符号引用验证
				准备prepare：
					1.为变量分配内存并设置变量的默认初始值，即零值。
					2.这块不包含应final修饰的static,因为final在编译的时候就被分配了，准备阶段会显式初始化
					3.这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。
				解析reslove：
					1.将常量池中的符号引用和转化为直接引用的过程
					2.事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
					3.符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中，直接引用说就是直接指向目标的指针/相对偏移量/一个间接定位到目标的句柄
					4.解析动作主要针对的是类或接口/字段/类方法/接口方法/方法类型等，对应常量池中的CONSTANT_CLASS_info/CONSTANT_Fieldref_info/CONSTANT_Methodref_info等。
			初始化：	1.初始化阶段就是执行类构造器方法<clinit>()的过程
						2.此方法不需要定义，是java编译器自动收集类中的所有类变量的赋值动作和静态代码快中的语句合并而来
						3.构造器方法中指令按语句在源文件中出现的顺序执行
						4.<clinit>()不同于类构造器。（关联：构造器是虚拟机视角下的<init>()）
						5.若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕
						6.虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。
	
						idea插件--jclasslib Bytecode Viewer
	类加载器分类：
				引导类加载器(Bootstrap ClassLoader，C C++写的)/自定义加载器(User-defined ClassLoader，继承Class Loader 类)两种
					Bootstrap Class Loader
							^^
							||
					Extension Class Loader
							^^
							||
					System Class Loader
							^^
							||	
							……
					User-defined ClassLoader
					
						注：四者的关系是包含关系。不是上下层也不是子父类的继承关系。
						
						虚拟机自带的加载器：
							引导类加载器(Bootstrap ClassLoader)---启动类加载器
								这个类加载器是c/c++ 语言实现的，嵌套在JVM 内部
								它用来加载java核心类库（JAVA_HOME/jre/lib/rt.jar resources.jar或sun.boot.class.path路径下内容），用于提供jvm自身需要的类
								并不继承自 java.lang.classLoader,没有父加载器
								加载扩展类和应用程序类加载器，并指定为他们的父类加载器
								处于安全考虑，Bootstrap启动类加载器只加载包名为java/javax/sun等开头的类
							扩展类加载器(Extension ClassLoader)
								java语言编写，由sun.misc.Launcher$ExtClassLoader 实现
								派生于ClassLoader类
								父类加载器为启动类加载器
								从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext目录下的子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载
							应用程序/系统类加载器(System/Application ClassLoader)
								java语言编写，由sun.misc.Launcher$AppClassLoader 实现
								派生于ClassLoader类
								父类加载器为扩展类加载器
								它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库‘
								该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载
								通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器
								从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext目录下的子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载
						用户自定义的加载器：
							隔离加载类
							修改类的加载方式
							扩展加载源
							防止源码泄露
	关于ClassLoader：
		一个抽象类，其后所有的类加载器都继承自ClassLoader
		获取途径：
			clazz.getClassLoader()
			Thread.currentThread().getContextClassLoader()
			ClassLoader.getSystemClassLoader()
			DriverManager.getCallerClassLoader()
	双亲委派机制：
		java虚拟机对class文件采用的是按需加载的方式，而且加载某个类的class文件时，java虚拟机采用的双亲委派方式也就是说把请求交给父类处理，它是一种任务委派模式。
		
		原理：
			1.如果一个类加载器收到一个类加载请求，首先会委托给自己父类加载器去执行
			2.如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终会到达顶层的启动类加载器
			3.如果父类加载器可以完成类加载任务，就会成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
		优势：
			1.避免重新加载
			2.保护程序的安全，防止核心的API随意被篡改。
	沙箱安全机制：
		自定义String类，但是在加载自定义String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载JDK自带的文件
		rt.jar包中java\lang\String.Class，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源码的保护。这就是沙箱安全机制。
	jvm中两个对象相同；
		必须类的包名和类名完全相同，并且加载class文件的类加载器对象为同一个。
	类加载器引用：
		JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分存放在方法区中。当解析一个类型到另一个类型引用的时候，JVM要保证这两个类型的类加载器是相同的。

2.运行时数据区	
	PC寄存器（程序计数器/钩子）：存储指向下一条指令的地址，也即将要执行指令的代码
		它是程序控制流的指示器，分支/循环/跳转/异常处理/线程恢复等基础功能都需要依赖这个计数器来完成
		字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
		它是唯一一个在java虚拟机规范中没有规定任何OOMERRor情况的区域。
		问题：
			1.使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址呢？
				因为CPU需要不停的切换各个线程，这个时候切换回来后就得知到从哪儿开始继续执行。jvm字节码解释器就需要通过改变PC寄存器的值来确认系一条应该执行什么样的字节码指令。
			2.PC寄存器为什么设置为线程私有呢？
				为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器
				由于CPU时间片轮限制，众多限制在并发执行过程中，任何一个确定的时刻，一个处理器或多个处理器中的一个内核，只会执行某个线程的一条指令。
				这必然回导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。
		CPU时间片：
			即CPU分配给每个程序的时间，每个线程被分配一个时间段，称作它的时间片。
			宏观上：我们可以同时打开多个应用程序，每个程序并行不悖。同时运行
			但在微观上：由于只有一个CPU一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。
		

```java
虚拟机栈：
	概述：
		由于跨平台的限制，Java的指令集都是根据栈来设计的。优点是跨平台指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。
		原理：
			1。不同线程中所包含的栈帧是不允许相互引用的。
			2。如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
			3。java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令，另外一种是抛出异常，两种都会导致栈帧弹出。
		栈是运行时的单位，堆是存储的单位。
		是什么：每个线程创建的时候都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的Java方法调用。是线程私有的
		生命周期：和线程一致
		作用：主管Java程序的运行，它保存方法的局部变量（8种基本数据类型/引用数据类型的地址）/部分结果 ，并参与方法的调用和返回。
		优点/特点：访问速度快，仅次于程序计数器/不存在GC问题/jvm对Java栈的操作只有两个：每个方法执行伴随着进栈/压栈，执行后的出栈工作
		栈可能出现的异常：stackoverflowerror(固定大小)OOM(可扩展大小)
    	设置栈的内存大小：-Xss.栈的大小直接决定了函数调用的最大可达深度
    		 private static int i = 1;
				public static void main(String[] args) {
    				System.out.println(i);
                        i++;
                        main(args);
                   }
	栈的存储单位
		每个线程都有自己的栈，栈中的数据以栈帧（stack Frame）格式存在
		在这个线程上正在执行的每个方法都各自对应一个栈帧
		栈帧是一个内存区块，是一个数据集，维系着方法执行过程中各种数据信息。
			类：filed（属性，字段，域）,method
			oop（面向对象）:类，对象
         栈帧内部结构：
         	局部变量表Local Variables
         	操作数栈 OPerand stack(或表达式栈)
         	动态链接 Dynamic Linking(或指向运行时常量池的方法引用)
         	方法返回地址 Return Adrress(或方法正常退出或者异常退出的定义)
         	一些附加信息
	局部变量表
		也称为局部变量数组或本地变量表
		定义为一个数字数组，主要用处存储方法参数和定义在方法体内部的局部变量，这些数据类型包括各类基本数据类型/对象引用（reference），以及returnAddress类型
		由于局部变量表->栈帧是线程私有的数据，不存在数据安全问题
		局部变量表所需容量大小是在编译器确定下来的，并保存在方法的code属性的maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。
		方法的嵌套调用次数是由栈的大小决定的，对一个函数而言，他的参数和局部变量越多使得局部变量表膨胀，它的栈帧就越大，导致其嵌套调用次数就会减少
		局部变量表的变量只在当前方法调用中有效，方法执行时虚拟机通过使用局部变量表完成参数值到参类变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量也会随之销毁。
		Slot(槽)
			参数值的存放总是在局部变量数字的index0开始，到数组长度-1的索引技术
			局部变量表最基本的存储单元是slot(槽)
			局部变量表中存放编译期可知的各种基本数据类型/引用类型/returnAddress类型的变量
			在局部变量表中，32位以内的类型只占用一个slot（包括returnAddress），64位类型（long和double）占用两个slot.
					byte/short/char在存储前被转换成int，boolean也被转化为int(0false,非0true)
					long/double占两个slot
             栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
	操作数栈operand stack:
		用数组实现的（栈可以用数组或链表来实现），主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
		每一个独立的栈帧内除了包含局部变量表之外还包含一个先进后出的操作数栈，也可以称之为表达式栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）
			某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。如执行复制/交换/求和等操作。
         操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建，这个方法的操作数栈是空的。每一个操作数栈都拥有一个再编译期就确定好的明确栈深度用于存储数值，保存至方法的code属性中，max_stack的值
         栈中的任何一个元素都可以是任意的Java数据类型（32bit的类型占用一个栈的单位深度，64bit占用两个）
         操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。
	代码追踪： 代码
	栈顶缓存技术(Top-of-StackCashing);
		前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈出栈指令，这同时意味着将需要更多的指令分派（instruction dispatch）次数和内存读写次数
		由于操作数是存储在内存中的，因此频繁的执行内存读写操作必然影响执行速度。为了解决这个问题hotspot JVM设计者们提出了栈顶缓存技术（TOS）,将栈顶元素全部缓存在物理的CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。
	（栈数据区）动态链接dynamic linking：指向运行时常量池的方法引用
		每一个栈帧内都包含着一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接dynamic linking。比如invokedynamic指令
		在Java源文件被编译到字节码文件中，所有的变量和方法引用都作为符号引用保存在class文件的常量池中。动态链接dynamic linking的作用就是为了将这些符号引用转换为调用方法的直接引用。
		常量池作用：为了提供一些符号和常量，便于指令识别。
	方法的调用:解析与分派
		JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关
			静态链接：当一个字节码文件被装在进JVM内部时
			动态链接：
		对应的方法绑定机制为早期绑定和晚期绑定。绑定时一个字段/方法或类在符号引用替换为直接引用的过程，这里仅发生一次。
			早期绑定：值被调用的目标方法如果在编译期可知，且运行期保持不变，即可将这个方法与所属的类型进行绑定，这样一来由于明确了被调用的目标方法究竟时哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用，
			晚期绑定：如果被调用的方法在编译期无法确定下来，只能够在程序运行期间根据实际的类型绑定相关方法，称之为晚期绑定。
		随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定差距，但是它们彼此之间始终保持着一个共性，那就是支持封装继承和多态的面向对象特性，既然这一类的编程语言具备多态性，那么自然也就具备早期绑定和晚期绑定两种绑定方式
		Java中任何一个普通的方法其实都具备虚函数的特性，它们相当于c++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。
		非虚方法：
			如果这个方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法（静态方法/私有方法/final方法/实例构造器/父类方法）。其他方法称为虚方法。
		指令	invokestatic  非虚方法，静态方法
		指令	invokespecial 非虚方法，init方法私有方法父类方法
		指令	invokevirtual  虚方法（final方法，父方法的final方法除外）
		指令	invokeInterface 虚方法，接口方法
		指令	invokedynamic 动态调用,动态解析出需要调用的方法，然后执行。
			invokedynamicjava在java7中为了实现动态语言类型支持而作的一种改进。但没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。知道java8的Lambda表达式出现，invokedynamic指令的生成才有了直接的生成方式。	java7中增加invokedynamic指令本质是对java虚拟机规范的修改，而不是对java语言规则的修改，增加虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言编辑器。
	（栈数据区）方法返回地址Return Address:存放调用该方法PC寄存器的值。
		一个方法结束（正常执行结束/出现未处理的异常，非正常退出）。无论哪种方式退出，在方法退出后都返回该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址时要通过异常表来确定，栈帧一般不会保存这部分信息。
		本质上，方法的退出就是当然栈帧出栈的过程。此时需要恢复上层方法的局部变量表/操作数栈/将返回值压入调用着栈帧的操作数栈，设置pc寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口不会给他的上层调用者返回任何返回值。		
	（栈数据区）一些附加信息
	栈的相关面试题
		举例栈溢出的情况？
		调整栈的大小，就能保证不出现溢出吗？不能
		分配栈内存越大越好吗？不是！
		垃圾回收是否会涉及到虚拟机栈？不涉及
		方法中定义的局部变量是否线程安全？（具体问题具体分析）
			方法内初始化，不返回 --安全
			方法参数入参，返回/返回 --不安全
			方法内初始化，返回 --不安全
        	内部产生，内部消亡是安全的，其余是不安全的。！！！
```
## 本地方法接口

### 	 什么是本地方法？

​	简单的讲，一个native method就是一个java调用非java代码的接口。一个native method是这样一个方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所持有，很多其它的编程语言都有这一机制。

​	在定义一个nativa method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外边实现的。 本地接口的作用时融合不同的编程语言为Java所用，初衷是融合C/C++程序。

​	不能使用abstract修饰。

### 	为什么使用Native Method?

​	效率，与java环境外交互，与操作系统交互，sun`s java

## 本地方法栈

​	Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用

​	本地方法栈，也是线程私有的。

​	允许被实现成固定或者是可扩展的内存大小。（在内存溢出方面是相同的StackoverflowError/OOM）

​	是用C语言实现的。它的具体做法是Native Method Stack 中等级的native方法，在Execution Engine 执行时加载本地方法库。

​	当某一个线程调用一个本地方法时，它就进入了一个全新的并且不受虚拟机限制的世界。它和虚拟机拥有同样的权限

- 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区

- 它甚至可以直接使用本地处理器中的寄存器

- 直接从本地内存堆中分配任意数量的内存

  并不是所有的JVM都指出本地方法，因为虚拟机规范并没有明确要求本地方法栈的使用语言/具体实现方式/数据结构等

  在hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。